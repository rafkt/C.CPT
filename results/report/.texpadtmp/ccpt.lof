\boolfalse {citerequest}\boolfalse {citetracker}\boolfalse {pagetracker}\boolfalse {backtracker}\relax 
\defcounter {refsection}{0}\relax 
\contentsline {figure}{\numberline {1}{\ignorespaces A Prediction Tree (PT), Inverted Index (II) and Lookup Table (LT)\relax }}{5}{figure.caption.4}
\defcounter {refsection}{0}\relax 
\contentsline {figure}{\numberline {2}{\ignorespaces In this example we have a list of numbers 5, 8, 8, 15, 32 with upper bound 36. For the upper bit array \(\lambda = \delimiter "4262304 \qopname \relax o{log}36/5\delimiter "5263305 = 2\). On right it is shown all the \(\lambda \) bits of all elements which are gathered together to create the lower-bets array. On left, the gaps for every number upper bits are calculated and stored sequentially in unary code in the upper-bits array.\relax }}{7}{figure.caption.5}
\defcounter {refsection}{0}\relax 
\contentsline {figure}{\numberline {3}{\ignorespaces Level-order bitmap representation\relax }}{9}{figure.caption.6}
\defcounter {refsection}{0}\relax 
\contentsline {figure}{\numberline {4}{\ignorespaces Generalized Jacobson encoding of a 4-ary tree: 1111 1111 1111 1011 1110 1101 1001 0000 0011 0000 1111 0010 1111 1001 1101 1100 0011 1101 1011 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000--- 200 bits\relax }}{10}{figure.caption.7}
